「光影代码」数字花园 - 系列教程章节规划
version：2.7

基于这份更完善的 PRD，我们对教程的章节进行了重构和扩展，使其更具结构性、更循序渐进。

  - 序章：现代独立开发者的“第一性原理”
    - 0.1: 项目愿景：为何是“数字花园”？(介绍 PRD v2.1)
    - 0.2: 我们的“作战地图”：项目章节与学习路径概览。
    - 0.3: 告别单打独斗：AI 协同开发时代的“独立开发者”新定义。
    - 0.4: 我们的“AI 开发宪法”：project.rules 的重要性与核心内容展示 (附录形式)。


第一部分：奠基 (The Foundation) - 搭建一个全球化的骨架
目标: 搭建一个拥有专业级 CI/CD 流程、统一视觉风格、且具备国际化基础的“黄金骨架”。

  - 第一章：项目启动与“设计基因”注入
    - 实战: 初始化 Next.js 项目，连接 GitHub，并立即部署到 Vercel，打通自动化部署流程。
    - 教程: 讲解 Vercel 的 Git 工作流和预览部署的价值。
    - 实战: 定义“设计基因”（字体、颜色），并配置 globals.css 和 tailwind.config.ts。
    - 核心实战 : 定义完整的双主题“设计基因” (Dark Mode Theming)
    - 教程: 讲解如何通过 CSS 变量，为亮色和暗色模式分别定义一套完整的设计令牌 (Design Tokens)。
    - 实战: 在 globals.css 中，完整地为 :root 和 .dark 两个作用域，配置好我们 PRD 中定义的所有颜色和样式变量。
      (在本章，我们只完成主题的“数据”和“配置”层面。用于切换主题的 ThemeProvider 和 ThemeToggle 交互式组件，将移至后续构建网站主布局 (Header/Layout) 的章节中实现，以保证学习路径的平滑。)
    - 实战: 初始化 shadcn/ui，并验证一个按钮组件是否已自动应用新主题。

  - 第二章：内容与数据的“双核”驱动 (Sanity & Prisma)
    - 实战: 搭建本地 Docker Postgres 环境，初始化 Prisma，并创建 User, Like, Comment 的初始 Schema。
    - 实战: 初始化 Sanity 项目，创建 production 和 development 两个 Dataset。
    - 实战: 在 Sanity 中为 post 和 photo 等内容类型，添加多语言支持。
    - 教程: 讲解如何在 Sanity Schema 中实现内容的国际化。
    - 教程: 详细讲解如何在 Sanity 中使用 @sanity/document-internationalization 插件，来实现内容的“关联文档”式多语言管理。
    - 核心实战: 建立内容关联模型。在 Sanity 中创建 author schema，并在 log schema 中建立对 author 的引用关系。

  - 第三章：认证的“外包”艺术 (Clerk Deep Dive)
    - 实战: 集成 Clerk，配置环境变量，在国际化的布局中添加 <UserButton> 等UI组件。
    - 实战: (新) 在 Clerk 后台配置 Google 和 GitHub 社交登录。
    - 教程: 讲解不同认证方式的优劣，并演示 Clerk 如何轻松集成多平台。
    - 实战: 创建 Clerk Webhook 处理器，实现用户数据到本地数据库的同步。

  - 第四章：构建全球化应用 (Internationalization, i18n)
    - 实战: 配置 i18n-config.ts，定义支持的语言。
    - 实战: 创建 middleware.ts，实现基于 Accept-Language 请求头的语言检测和自动重定向。
    - 教程: 深入剖析 Middleware 在 i18n 中的核心作用。
    - 实战: 重构项目结构，创建 app/[lang] 动态路由，并创建 dictionaries (如 en.json, zh.json)。
    - 实战: 修改根布局和首页，使其能根据 lang 参数加载并显示对应语言的文本。
    - 实战: 创建一个可复用的语言切换器客户端组件 (LanguageSwitcher.tsx)，并将其集成到网站布局中。
 

第二部分：构建“数字花园” (Feature-Driven Implementation)
目标: 将我们的“设计蓝图”和“后端能力”结合，一步步地将“光影代码”这个产品从概念变为现实。

  第五章: 构建网站的“视觉骨架”与核心体验
  目标: 搭建一个用户可感知的、包含核心导航和基础UI的网站框架。
  实战:
  - 搭建主框架: 创建全站的 Header 和 Footer 组件。
  - 实现核心交互组件:
    - 在 Header 中，集成 Clerk 的 <UserButton /> 和我们规划的 “语言切换”按键 (<LanguageSwitcher />)。
    - 创建 theme-provider.tsx 和 theme-toggle.tsx，将亮暗模式切换功能放入 Header 或 Footer。
  - 创建核心页面的布局结构:
    - 创建 HomePageShell，实现多个“楼层”的垂直布局。
    - 创建 GalleryListPageShell，使用 Tailwind CSS Grid 实现响应式的砌体式网格布局。
    - 创建 GalleryDetailPageShell，实现顶部“标题/描述区”和下方“瀑布流内容区”的布局。
    - 创建 LogPageShell，实现经典的文章“内容区 + 侧边栏”布局。

  第六章: 实现“只读”的内容体验
  目标: 将后端数据注入到我们已经建好的页面骨架中，让网站“活”起来。
  实战:
  - 创建数据访问层 (DAL): 在 dal.ts 中，编写所有数据读取函数（如 getPhotos, getPostBySlug），并用 React.cache 封装。
  - 增强 DAL: 确保 DAL 中的数据获取函数，能够根据 lang 参数，从 Sanity 获取国际化的内容。
  - 教程: 在此过程中，深入讲解 DAL 层如何封装数据库查询与（未来的）权限判断逻辑。
  - 填充页面内容:
    - 改造所有页面（如 /, /gallery, /log/[slug]），使其变为服务端组件。
    - 在这些组件中，调用 DAL 函数，获取真实数据，并将数据“填充”到我们上一章创建好的 HomePageShell, GalleryListPageShell 等布局中。
  - 核心实战 (新): 渲染关联数据与富文本。
    - 在文章详情页，通过 GROQ 查询并展示作者信息。
    - 安装 @sanity/code-input 插件，并创建一个 React 组件来实现代码块的高亮渲染。

  第七章: 注入灵魂：实现用户交互
  目标: 为登录用户开启“互动”能力，让他们从“访客”变为“参与者”。
  实战:
  - 创建交互组件: 构建客户端的 <LikeButton> 和 <CommentForm>。
  - 扩展 DAL (写操作): 在 dal.ts 中，补充所有数据写入的函数（如 createComment, toggleLike）。
  - 编写 Server Actions (对应你的要点 8): 创建 likeAction 和 commentAction，实现一个包含 Zod 校验、调用 DAL 写入数据库、以及调用 revalidateTag 的完整后端逻辑。
  - 实现表单状态: 使用 useActionState Hook，为评论表单添加优雅的 pending 和错误提示状态。

  第八章: 内容创作者的终极工作流
  目标: 打通内容创作与前端预览的“任督二脉”，实现“所见即所得”。
  实战:
  - 配置 Sanity Webhook: 在 Sanity后台配置 Webhook，指向我们的 Next.js 应用。
  - 创建 Webhook 接收器: 创建一个安全的 API Route 来接收 Sanity 的通知，并在验证后执行 revalidateTag。
  - 实现 Live Preview: 配置 Next.js 的 Draft Mode 和 next-sanity 的预览客户端，实现最终的实时预览效果。


第三部分：打磨与发布 (Polish & Launch)
目标: 完善用户体验细节，增加测试覆盖，并完成最终的生产部署。

  - 第九章：测试、授权与站内管理
    - 实战: 使用 Playwright 为“用户登录并成功评论”的核心流程，录制并生成 E2E 测试。
    - 实战: 使用 Vitest 为 Server Action 编写单元测试。
    - 实战: (新) 在 Clerk 后台为自己分配 admin 角色，并使用 <Protect role="admin"> 构建一个简单的、用于管理评论的站内后台页面。
    - 教程: 讲解如何实现简单的、基于角色的访问控制 (RBAC)。

  - 第十章：生产环境部署与持续迭代
    - 实战: 在 Vercel 后台，完成所有生产环境变量的最终配置。
    - 教程: 提供一份详细的“上线前检查清单 (Pre-launch Checklist)”。
    - 实战: 通过 PR 和预览部署，完成最后一轮审查，最终合并到 main 分支，正式上线！