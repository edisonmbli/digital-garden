「光影代码」数字花园 - 系列教程章节规划
version：2.3

基于这份更完善的 PRD，我们对教程的章节进行了重构和扩展，使其更具结构性、更循序渐进。

  - 序章：现代独立开发者的“第一性原理”
    - 0.1: 项目愿景：为何是“数字花园”？(介绍 PRD v2.1)
    - 0.2: 我们的“作战地图”：项目章节与学习路径概览。
    - 0.3: 告别单打独斗：AI 协同开发时代的“独立开发者”新定义。
    - 0.4: 我们的“AI 开发宪法”：project.rules 的重要性与核心内容展示 (附录形式)。

第一部分：奠基 (The Foundation) - 搭建一个全球化的骨架
目标: 搭建一个拥有专业级 CI/CD 流程、统一视觉风格、且具备国际化基础的“黄金骨架”。

  - 第一章：项目启动与“设计基因”注入
    - 实战: 初始化 Next.js 项目，连接 GitHub，并立即部署到 Vercel，打通自动化部署流程。
    - 教程: 讲解 Vercel 的 Git 工作流和预览部署的价值。
    - 实战: 定义“设计基因”（字体、颜色），并配置 globals.css 和 tailwind.config.ts。
    - 核心实战 : 定义完整的双主题“设计基因” (Dark Mode Theming)
    - 教程: 讲解如何通过 CSS 变量，为亮色和暗色模式分别定义一套完整的设计令牌 (Design Tokens)。
    - 实战: 在 globals.css 中，完整地为 :root 和 .dark 两个作用域，配置好我们 PRD 中定义的所有颜色和样式变量。
      (在本章，我们只完成主题的“数据”和“配置”层面。用于切换主题的 ThemeProvider 和 ThemeToggle 交互式组件，将移至后续构建网站主布局 (Header/Layout) 的章节中实现，以保证学习路径的平滑。)
    - 实战: 初始化 shadcn/ui，并验证一个按钮组件是否已自动应用新主题。

第二部分：构建后端核心 (The Backend Core)
目标: 在开始任何复杂的前端功能之前，先搭建好一个完整、可靠、且数据可以流动的后端服务。

  - 第二章：内容与数据的“双核”驱动 (Sanity & Prisma)
    - 实战: 搭建本地 Docker Postgres 环境，初始化 Prisma，并创建 User, Like, Comment 的初始 Schema。
    - 实战: 初始化 Sanity 项目，创建 production 和 development 两个 Dataset。
    - 实战: 在 Sanity 中为 post 和 photo 等内容类型，添加多语言支持。
    - 教程: 讲解如何在 Sanity Schema 中实现内容的国际化。
    - 教程: 详细讲解如何在 Sanity 中使用 @sanity/document-internationalization 插件，来实现内容的“关联文档”式多语言管理。

  - 第三章：认证的“外包”艺术 (Clerk Deep Dive)
    - 实战: 集成 Clerk，配置环境变量，在国际化的布局中添加 <UserButton> 等UI组件。
    - 实战: (新) 在 Clerk 后台配置 Google 和 GitHub 社交登录。
    - 教程: 讲解不同认证方式的优劣，并演示 Clerk 如何轻松集成多平台。
    - 实战: 创建 Clerk Webhook 处理器，实现用户数据到本地数据库的同步。

  - 第四章：构建全球化应用 (Internationalization, i18n)
    - 实战: 配置 i18n-config.ts，定义支持的语言。
    - 实战: 创建 middleware.ts，实现基于 Accept-Language 请求头的语言检测和自动重定向。
    - 教程: 深入剖析 Middleware 在 i18n 中的核心作用。
    - 实战: 重构项目结构，创建 app/[lang] 动态路由，并创建 dictionaries (如 en.json, zh.json)。
    - 实战: 修改根布局和首页，使其能根据 lang 参数加载并显示对应语言的文本。
    - 实战: 创建一个可复用的语言切换器客户端组件 (LanguageSwitcher.tsx)，并将其集成到网站布局中。
  
第三部分：核心功能实现 (Core Implementation)
目标: 采用分层架构和最佳实践，构建出网站的核心功能，让数据真正“流动”起来。

  - 第五章: 构建网站主框架与数据访问层 (DAL)
    - 实战: 构建全站的 Header 和 Footer，并将 Clerk 的 <UserButton> 和我们上一章创建的“语言切换器”放入其中。
    - 实战: 创建 dal.ts，编写所有数据获取函数（如getPosts, getPhotos），并用 React.cache 包裹。
    - 教程: 深入讲解 DAL 层如何封装数据库查询与权限判断。

  - 第六章：构建网站的“视觉骨架” (Layouts & UI Shells)
    - 教程: 讲解如何构建可复用的、贯穿全站的 Header 和 Footer 组件。
    - 核心实战 (承接第一章): 正式实现亮暗模式切换功能。
      - 创建 theme-provider.tsx 客户端组件并应用于根布局。
      - 创建 theme-toggle.tsx 交互式UI组件，并将其集成到 Header 中。
    - 实战: 在 Header 中，集成 Clerk 的 <UserButton>，并为 /gallery 和 /log 创建导航链接。
    - 核心实战 (新): 搭建核心页面的布局结构。
      - 首页 (/): 创建 HomePageShell，实现多个“楼层”的垂直布局结构。
      - 影像馆列表页 (/gallery): 创建 GalleryListPageShell，使用 Tailwind CSS Grid 实现响应式的砌体式网格 (Masonry Grid) 基础布局。
      - 影像馆详情页 (/gallery/[slug]): 创建 GalleryDetailPageShell，实现顶部“标题/描述区”和下方“瀑布流内容区”的宏观布局。
      - 日志列表/详情页 (/log, /log/[slug]): 创建 LogPageShell，实现经典的文章“内容区 + 侧边栏”布局。

  - 第七章：构建数据访问层 (DAL) 与 Server Components
    - 教程: 讲解如何通过 DAL 获取数据，并将其传递给 Server Components。
    - 实战: 在我们上一章创建好的 HomePageShell, GalleryListPageShell 等布局中，“填充” 真实的数据。
    - 实战: 创建 dal.ts，编写 getPosts() 等数据获取函数，并用 React.cache 包裹。
    - 实战: 构建一个纯服务端的、国际化的文章列表页 (/log)。

  - 第八章：实现用户交互 (Server Actions & Revalidation)
    - 实战: 构建客户端的“点赞按钮”和“评论表单”组件。
    - 实战: 编写 likeAction 和 createCommentAction，包含 Zod 校验、调用 DAL 写入数据库，以及调用 revalidateTag 的完整逻辑。
    - 教程: 详解 Server Action 如何与 useActionState 结合，实现优雅的表单错误处理和 pending 状态。

  - 第九章：Sanity 集成与终极预览体验
    - 实战: 增强 DAL，加入从 Sanity 获取国际化内容的函数。
    - 实战: 配置 Sanity Webhook，并创建一个 API Route 来接收通知和执行 revalidateTag。
    - 核心实战: 配置 Next.js 的 Draft Mode 和 next-sanity 的预览客户端，实现最终的 Live Preview 效果。

第四部分：打磨与发布 (Polish & Launch)
目标: 完善用户体验细节，增加测试覆盖，并完成最终的生产部署。

  - 第十章：测试、授权与站内管理
    - 实战: 使用 Playwright 为“用户登录并成功评论”的核心流程，录制并生成 E2E 测试。
    - 实战: 使用 Vitest 为 Server Action 编写单元测试。
    - 实战: (新) 在 Clerk 后台为自己分配 admin 角色，并使用 <Protect role="admin"> 构建一个简单的、用于管理评论的站内后台页面。
    - 教程: 讲解如何实现简单的、基于角色的访问控制 (RBAC)。

  - 第十一章：生产环境部署与持续迭代
    - 实战: 在 Vercel 后台，完成所有生产环境变量的最终配置。
    - 教程: 提供一份详细的“上线前检查清单 (Pre-launch Checklist)”。
    - 实战: 通过 PR 和预览部署，完成最后一轮审查，最终合并到 main 分支，正式上线！