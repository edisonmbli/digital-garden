5）构建网站的“视觉骨架”与核心体验
欢迎来到我们旅程的第五章！
在前四章，我们已经为“数字花园”铸造了坚不可摧的“地基”——从设计系统、数据核心、认证安保到全球化能力，一切准备就绪。现在，是时候开始真正的“建造”工程了：我们要为这个项目，搭建起用户能真实感知到的、结构清晰的视觉框架。
章节目标: 在这一章，我们将把 PRD 中的“线框图”，转化为用户可感知的、结构清晰的网站“视觉骨架 (UI Shells)”。我们将搭建起全站的导航框架，为所有核心页面砌好“毛坯房”，并正式实现亮暗模式切换的核心体验。

5.1 核心理念：从“零件”到“框架”
在这一章，我们的核心工作是将之前准备好的各种“零件”（如 Button, Clerk 组件, i18n 逻辑）组装成一个连贯的、可交互的网站“框架”。我们将遵循两个重要的最佳实践：
> 专家提示：如何组织你的组件？
> 你会注意到，我们将手写一些新的、与我们业务紧密相关的组件（如 Header, Footer）。这些组件应该放在哪里？
>   - components/ui: 这个文件夹由 shadcn/ui 自动管理。它存放的是我们“召唤”来的、通用的、原子级的 UI 组件（如 <Button>, <Card>）。
>   - app/ui: 这是我们自己手写组件的“家”。所有为“数字花园”量身定制的、可复用的业务组件（如 <Header>, <Footer>, 以及我们接下来会创建的所有 PageShell），都将存放在这里。
> 遵循这个约定，能让我们的项目结构始终保持清晰：components/ 是我们的“第三方零件库”，而 app/ui/ 则是我们自己“组装好的模块”。

> 专家提示：如何避免“空洞感”？
> 在真实数据接口就绪前，直接搭建 UI 骨架可能会让页面看起来空空如也，难以判断布局是否正确。为了解决这个问题，我们将采用一种专业的“占位符驱动UI开发 (Placeholder-Driven UI)”模式：先用一组结构一致的“假数据”来填充UI，这能让我们的UI开发与后端数据获取完全解耦，并提供即时的视觉反馈。

5.2 准备“占位符”内容 (Placeholder Data)
实战：创建 placeholder-data.ts
1. 创建文件: 在 app/lib/ 目录下，创建一个新文件 placeholder-data.ts。
2. 写入代码: 这份数据模仿了我们未来从 Sanity 和 Prisma 中获取的数据结构。
  ```
  // app/lib/placeholder-data.ts
  
  // 模拟影像馆“影像组”的数据
  export const placeholderGroups = [
    { slug: 'street-photography-2024', name: 'Street Photography 2024' },
    { slug: 'portraits-in-nature', name: 'Portraits in Nature' },
    { slug: 'iceland-aurora', name: 'Iceland Aurora' },
    { slug: 'tokyo-nights', name: 'Tokyo Nights' },
    { slug: 'architectural-lines', name: 'Architectural Lines' },
    { slug: 'monochrome-world', name: 'Monochrome World' },
  ];
  
  // 模拟“开发者日志”的数据
  export const placeholderLogs = [
    { slug: 'chapter-1', title: 'Chapter 1: Project Kick-off & Design DNA' },
    { slug: 'chapter-2', title: 'Chapter 2: The Dual-Core of Data & Content' },
    { slug: 'chapter-3', title: 'Chapter 3: The Art of Outsourcing Authentication' },
    { slug: 'chapter-4', title: 'Chapter 4: Building a Globalized Application' },
  ];
  ```

5.3 构建全站通用框架：<Header />, <Footer /> 与主题切换
现在，我们来搭建贯穿所有页面的顶部和底部，并正式实现“亮暗模式切换”功能。

实战：创建/更新核心 UI 组件
> 提示：ThemeProvider & ThemeToogle为第一章遗留待实现组件，支持亮暗模式的切换
> 教程：揭秘亮暗模式切换的魔法
> 在我们把主题切换功能集成进来之前，让我们先花一分钟，理解一下它背后优雅的工作原理。这套机制由三个“齿轮”紧密啮合而成：
> 1. Tailwind CSS 的“class”策略: 在我们的 tailwind.config.ts 文件中，我们设置了 darkMode: "class"。这等于告诉 Tailwind：“请不要自动根据用户的系统设置来切换主题。相反，请在 CSS 中，为暗黑模式生成一套以 .dark > 类为前缀的样式。何时添加或移除这个 .dark 类，将由我们自己用 JavaScript 来控制。”
> 2. next-themes 库: 它就是那个负责控制 .dark 类的“智能开关”。
>   - <ThemeProvider>: 这个组件（我们将其封装在 app/ui/theme-provider.tsx 中）是一个“状态管理器”。它会安全地、无闪烁地在服务端和客户端之间同步当前的主题选择（亮色、暗色或跟随系统），并通过 React Context 将这个状态提供给应用中的任何组件。
>   - <ThemeToggle />: 这是一个“用户遥控器”。它使用 next-themes 提供的 useTheme Hook，来读取当前主题，并允许用户通过点击，来切换主题。当用户切换时，ThemeProvider 会自动地在 <html> 标签上添加或移除 .dark 类。
> 3. 我们的 globals.css: 这是我们的“主题皮肤库”。当 <html> 标签上没有 .dark 类时，浏览器会应用我们在 :root 中定义的 CSS 变量（亮色主题）。而一旦 <ThemeProvider> 为 <html> 加上了 class="dark"，浏览器就会立刻应用我们在 .dark > 中定义的、优先级更高的另一套 CSS 变量（暗黑主题）。
> 理解了这个流程，你就会明白，我们接下来要做的，就是将这三个“齿轮”正确地组装在一起。

1. theme-provider.tsx:
  ``` 
  // app/ui/theme-provider.tsx
  'use client'
  
  import { ThemeProvider as NextThemesProvider } from 'next-themes'
  import type { ThemeProviderProps } from 'next-themes'
  
  // 2. 我们的 ThemeProvider 组件的 props 类型，完全等同于 NextThemesProvider 的 props 类型
  export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
    // 3. 将所有 props 透明地传递给被包裹的组件
    return <NextThemesProvider {...props}>{children}</NextThemesProvider>
  }
  ```

2. theme-toggle.tsx: 
  ```
  // app/components/ui/theme-toggle.tsx
  
  'use client'
  
  import * as React from 'react'
  import { Moon, Sun } from 'lucide-react'
  import { useTheme } from 'next-themes'
  
  import { Button } from '@/components/ui/button'
  import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuTrigger,
  } from '@/components/ui/dropdown-menu'
  
  export function ThemeToggle() {
    const { setTheme } = useTheme()
  
    return (
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="outline" size="icon">
            <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
            <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
            <span className="sr-only">Toggle theme</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem onClick={() => setTheme('light')}>
            Light
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => setTheme('dark')}>
            Dark
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => setTheme('system')}>
            System
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    )
  }
  ```

> 提示：Footer为本章新增组件；而Header主要添加了ThemeToggle、以及gallery和log访问入口
3. Header.tsx:
  ```
// app/ui/header.tsx

import Link from 'next/link'
import { headers } from 'next/headers'
import { UserButton, SignInButton, SignedIn, SignedOut } from '@clerk/nextjs'
import { Button } from '@/components/ui/button'
import { ThemeToggle } from '@/app/ui/theme-toggle'
import { LanguageSwitcher } from '@/components/ui/language-switcher'
import { getDictionary } from '@/lib/dictionary'
import { type Locale, i18n } from '@/i18n-config'

export async function Header() {
  const headersList = await headers()
  const lang = (headersList.get('x-locale') as Locale) || i18n.defaultLocale
  const dictionary = await getDictionary(lang)

  const navItems = [
    { href: `/${lang}/about`, label: dictionary.header.about },
    { href: `/${lang}/gallery`, label: dictionary.header.gallery },
    { href: `/${lang}/log`, label: dictionary.header.log },
  ]

  return (
    <header className="sticky top-0 z-50 w-full border-b border-border/40 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <nav className="container mx-auto flex h-14 max-w-screen-2xl items-center justify-between px-4 sm:px-6 lg:px-8">
        {/* 导航栏 */}
        <div className="flex items-center gap-6">
          <Link href={`/${lang}`} className="font-bold text-xl tracking-tight">
            {dictionary.header.title}
          </Link>
          <nav className="hidden md:flex items-center gap-4">
            {navItems.map((item) => (
              <Link
                key={item.href}
                href={item.href}
                className="text-sm font-medium text-muted-foreground transition-colors hover:text-foreground"
              >
                {item.label}
              </Link>
            ))}
          </nav>
        </div>

        {/* 登录按钮 */}
        <div className="flex items-center gap-4">
          <div className="flex items-center gap-2">
            <LanguageSwitcher />
            <ThemeToggle />
          </div>

          <SignedIn>
            <div className="h-6 w-px bg-border" />
            <UserButton />
          </SignedIn>

          <SignedOut>
            <SignInButton mode="modal">
              <Button variant="outline">{dictionary.header.signIn}</Button>
            </SignInButton>
          </SignedOut>
        </div>
      </nav>
    </header>
  )
}
  ```

4. Footer.tsx:
  ```
  // app/ui/Footer.tsx
  import Link from 'next/link'
  import { getDictionary } from '@/lib/dictionary'
  import { headers } from 'next/headers'
  import { type Locale, i18n } from '@/i18n-config'
  
  export async function Footer() {
    const headersList = await headers()
    const lang = (headersList.get('x-locale') as Locale) || i18n.defaultLocale
    const dictionary = await await getDictionary(lang)
  
    return (
      <footer className="w-full py-6 border-t">
        <div className="container mx-auto flex flex-col items-center justify-center gap-4 px-4 sm:px-6 lg:px-8 md:h-24">
          <p className="text-balance text-center text-sm leading-loose text-muted-foreground">
            {dictionary.footer.built_in_public_by_}{' '}
            {dictionary.footer.source_code_available_on_}
            <Link
              href="https://github.com/edisonmbli/digital-garden"
              target="_blank"
              rel="noreferrer"
              className="font-medium underline underline-offset-4"
            >
              GitHub
            </Link>
            .
          </p>
        </div>
      </footer>
    )
  }
  ```
> 教程：剖析“全出血 (Full-Bleed)”布局
> 注意我们的 Header 和 Footer 的结构：最外层的 <header>/<footer> 标签是 100% 宽度的，它负责背景、边框等视觉样式。而在其内部，我们用一个 <div className="container ..."> 来包裹真正的内容，这个 container 会约束内容的最大宽度并使其居中。这种“外层通栏，内层居中”的模式，是构建专业、美观网页布局的黄金法则。

> 提示：需要更新@\dictionaries\en.json、zh.json，以便适配国际化多语言文案

5.4 在小屏幕上“优雅地”收纳导航 (Reponsive Design for Nav)
实战：用 shadcn/ui 的 Sheet 组件，构建移动端抽屉菜单
shadcn/ui 已经为我们提供了实现这个功能的、完美的“积木块”—— <Sheet /> 组件。它能帮助我们轻松地创建一个漂亮的侧边滑出式抽屉。

第一步：“召唤”我们需要的组件
`pnpm dlx shadcn@latest add sheet`

第二步：创建独立的移动端导航组件 MobileNav.tsx
为了保持代码的清晰和可维护性，我们将把所有与“汉堡菜单”相关的逻辑，都封装到一个独立的客户端组件中。
1. 创建文件: app/ui/mobile-nav.tsx
2. 写入代码:
  ```
  'use client'

  import * as React from 'react'
  import Link from 'next/link'
  import { usePathname } from 'next/navigation'
  import { Menu, Mountain } from 'lucide-react'

  import { Button } from '@/components/ui/button'
  import {
    Sheet,
    SheetContent,
    SheetTrigger,
    SheetHeader,
    SheetTitle,
  } from '@/components/ui/sheet'
  import { type NavItem } from '@/types/index'
  import { getDictionary } from '@/lib/dictionary'

  type DictionaryType = Awaited<ReturnType<typeof getDictionary>>

  export function MobileNav({
    navItems,
    dictionary,
  }: {
    navItems: NavItem[]
    dictionary: DictionaryType
  }) {
    const [open, setOpen] = React.useState(false)
    const pathName = usePathname()
    const lang = pathName.split('/')[1]

    return (
      <Sheet open={open} onOpenChange={setOpen}>
        <SheetTrigger asChild>
          <Button
            variant="ghost"
            className="mr-2 px-0 text-base hover:bg-transparent focus-visible:bg-transparent focus-visible:ring-0 focus-visible:ring-offset-0 md:hidden"
          >
            <Menu className="h-6 w-6" />
            <span className="sr-only">Toggle Menu</span>
          </Button>
        </SheetTrigger>
        <SheetContent side="left" className="pr-0">
          {/* 添加 SheetHeader 和 SheetTitle 来满足无障碍要求 */}
          <SheetHeader>
            <SheetTitle className="sr-only">
              {dictionary.header.title} Navigation Menu
            </SheetTitle>
          </SheetHeader>

          <Link
            href={`/${lang}`}
            className="mr-6 flex items-center space-x-2"
            onClick={() => setOpen(false)}
          >
            <Mountain className="h-6 w-6" />
            <span className="font-bold">{dictionary.header.title}</span>
          </Link>

          <div className="my-4 h-[calc(100vh-8rem)] pb-10 pl-6">
            <nav className="flex flex-col space-y-3" role="navigation">
              {navItems?.map(
                (item) =>
                  item.href && (
                    <Link
                      key={item.href}
                      href={item.href}
                      onClick={() => setOpen(false)}
                      className="text-sm font-medium text-muted-foreground transition-colors hover:text-foreground"
                    >
                      {item.label}
                    </Link>
                  )
              )}
            </nav>
          </div>
        </SheetContent>
      </Sheet>
    )
  }
  ```

第三步：升级我们的 <Header /> 组件
现在，我们在 Header 中，同时集成“桌面端导航”和“移动端导航”，并用 Tailwind CSS 的响应式工具类，来控制它们在不同屏幕尺寸下的显隐。
修正后的 Header.tsx (响应式):
  ```
  // app/ui/header.tsx

  import Link from 'next/link'
  import { headers } from 'next/headers'
  import { UserButton, SignInButton, SignedIn, SignedOut } from '@clerk/nextjs'
  import { Button } from '@/components/ui/button'
  import { ThemeToggle } from '@/app/ui/theme-toggle'
  import { LanguageSwitcher } from '@/components/ui/language-switcher'
  import { getDictionary } from '@/lib/dictionary'
  import { type Locale, i18n } from '@/i18n-config'
  import { MobileNav } from '@/app/ui/mobile-nav'

  export async function Header() {
    const headersList = await headers()
    const lang = (headersList.get('x-locale') as Locale) || i18n.defaultLocale
    const dictionary = await getDictionary(lang)

    const navItems = [
      { href: `/${lang}/about`, label: dictionary.header.about },
      { href: `/${lang}/gallery`, label: dictionary.header.gallery },
      { href: `/${lang}/log`, label: dictionary.header.log },
    ]

    return (
      <header className="sticky top-0 z-50 w-full border-b border-border/40 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <nav className="container mx-auto flex h-14 max-w-screen-2xl items-center justify-between px-4 sm:px-6 lg:px-8">
          {/* 导航栏 */}
          <div className="flex items-center gap-6">
            {/* 移动端导航：只在小于 md 断点时显示 */}
            <div className="md:hidden">
              <MobileNav navItems={navItems} dictionary={dictionary} />
            </div>
            {/* 桌面导航：只在大于 md 断点时显示 */}
            <Link
              href={`/${lang}`}
              className="hidden font-bold text-xl tracking-tight md:block"
            >
              {dictionary.header.title}
            </Link>
            <nav className="hidden md:flex items-center gap-4">
              {navItems.map((item) => (
                <Link
                  key={item.href}
                  href={item.href}
                  className="text-sm font-medium text-muted-foreground transition-colors hover:text-foreground"
                >
                  {item.label}
                </Link>
              ))}
            </nav>
          </div>

          {/* 登录按钮 */}
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-2">
              <LanguageSwitcher />
              <ThemeToggle />
            </div>

            <SignedIn>
              <div className="h-6 w-px bg-border" />
              <UserButton />
            </SignedIn>

            <SignedOut>
              <SignInButton mode="modal">
                <Button variant="outline">{dictionary.header.signIn}</Button>
              </SignInButton>
            </SignedOut>
          </div>
        </nav>
      </header>
    )
  }
  ```

> 教程：定义共享类型 NavItem
> 为了让 Header 和 MobileNav 都能准确地知道 navItems 数组的“形状”，我们可以在项目根目录创建一个 types/index.ts 文件，来定义一个共享的类型：
> // types/index.ts
> export type NavItem = {
>   label: string;
>   href: string;
>   disabled?: boolean;
> };
> 然后在 MobileNav.tsx 中 import { type NavItem } from '@/types';。这是一种非常专业的 TypeScript 实践。

5.5 搭建核心页面的“毛坯房” (Page Shells)
现在，我们为每个核心页面，创建只包含布局结构、并消费“假数据”的“页面外壳”组件。

实战：创建首页、影像馆、日志的 Shells
1. 首页 (/): 创建 app/ui/home-page-shell.tsx，在其中构建一个沉浸式的 Hero 组件布局。
  ```
  import { headers } from 'next/headers'
  import { Button } from '@/components/ui/button'
  import { getDictionary } from '@/lib/dictionary'
  import { type Locale, i18n } from '@/i18n-config'

  export async function HomePageShell() {
    const headersList = await headers()
    const lang = (headersList.get('x-locale') as Locale) || i18n.defaultLocale
    const dictionary = await getDictionary(lang)

    return (
      <div className="w-full py-12">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="relative h-[calc(100vh-16rem)] flex flex-col items-center justify-center text-center rounded-lg bg-muted/50">
            {/* 背景效果 - 现在只应用在容器内 */}
            {/* 在第六章，这里会变成一个背景图/视频 */}
            <div className="absolute inset-0 bg-black/30 rounded-lg" />
            <div className="relative max-w-4xl mx-auto px-4">
              <h1 className="text-5xl font-bold tracking-tighter sm:text-7xl">
                {dictionary.homepage.title}
              </h1>
              <p className="mx-auto mt-4 max-w-[700px] text-lg text-muted-foreground">
                {dictionary.homepage.description}
              </p>
              <div className="mt-8">
                <Button size="lg">{dictionary.homepage.enter_button}</Button>
              </div>
            </div>
          </div>
        </div>
      </div>
    )
  }
  ```

2. 影像馆列表页 (/gallery): 创建 app/ui/gallery-page-shell.tsx，在其中导入 placeholderGroups 并使用 .map() 渲染出一个响应式的网格布局。
  ```
  // app/ui/gallery-page-shell.tsx
  import { placeholderGroups } from '@/lib/placeholder-data'

  export function GalleryPageShell() {
    return (
      <div className="w-full py-12">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
            {placeholderGroups.map((group) => (
              <div
                key={group.slug}
                className="h-80 rounded-lg bg-muted flex items-center justify-center"
              >
                <h2 className="text-2xl font-bold">{group.name}</h2>
              </div>
            ))}
          </div>
        </div>
      </div>
    )
  }
  ```

3. 日志列表页 (/log): 创建 app/ui/log-page-shell.tsx，在其中导入 placeholderLogs 并使用 .map() 渲染出一个文章链接列表。
  ```
  // app/ui/log-page-shell.tsx
  import { headers } from 'next/headers'
  import { placeholderLogs } from '@/lib/placeholder-data'
  import Link from 'next/link'
  import { getDictionary } from '@/lib/dictionary'
  import { type Locale, i18n } from '@/i18n-config'

  export async function LogPageShell() {
    const headersList = await headers()
    const lang = (headersList.get('x-locale') as Locale) || i18n.defaultLocale
    const dictionary = await getDictionary(lang)

    return (
      <div className="w-full py-12">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-12">
            <h1 className="text-4xl font-bold">{dictionary.develop.title}</h1>
            <p className="text-muted-foreground mt-2">
              {dictionary.develop.description}
            </p>
            {/* 未来这里的搜索/筛选区 */}
          </div>
          <div className="space-y-4">
            {placeholderLogs.map((log) => (
              <Link
                key={log.slug}
                href={`/log/${log.slug}`}
                className="block p-4 border rounded-lg hover:bg-muted"
              >
                <h3 className="font-semibold">{log.title}</h3>
              </Link>
            ))}
          </div>
        </div>
      </div>
    )
  }
  ```

5.6 最终整合与本章验收
最后，我们将所有“骨架”都组装起来。
1. 实战：更新根布局 app/[lang]/layout.tsx:
  - 导入并使用 <Header /> 和 <Footer />，并确保 main 标签拥有 flex-1 类以撑满可用空间。
  ```
  import type { Metadata } from 'next'
  import { Figtree, Lora } from 'next/font/google'
  import '@/app/ui/globals.css'
  import { ThemeProvider } from '@/app/ui/theme-provider'
  import { ClerkProvider } from '@clerk/nextjs'
  import { Header } from '@/app/ui/header'
  import { Footer } from '@/app/ui/footer'
  import { Toaster } from '@/components/ui/sonner'
  import { type Locale } from '@/i18n-config'
  import { getDictionary, getClerkLocalization } from '@/lib/dictionary'
  
  const fontSans = Figtree({
    subsets: ['latin'],
    display: 'swap',
    variable: '--font-sans',
  })
  
  const fontSerif = Lora({
    subsets: ['latin'],
    display: 'swap',
    variable: '--font-serif',
  })
  
  export const metadata: Metadata = {
    title: 'Create Next App',
    description: 'Generated by create next app',
  }
  
  export default async function RootLayout({
    children,
    params,
  }: {
    children: React.ReactNode
    params: Promise<{ lang: Locale }>
  }) {
    // 在服务端获取所有需要的国际化资源
    const { lang } = await params
    const dictionary = await getDictionary(lang)
    const clerkLocalization = getClerkLocalization(lang)
  
    return (
      <ClerkProvider localization={{ ...clerkLocalization, ...dictionary.clerk }}>
        <html lang="en" suppressHydrationWarning>
          <body
            className={`${fontSans.variable} ${fontSerif.variable} font-sans min-h-screen w-full bg-background text-foreground antialiased`}
          >
            <ThemeProvider
              attribute="class"
              defaultTheme="system"
              enableSystem
              disableTransitionOnChange
            >
              <div className="relative flex flex-col min-h-screen w-full">
                <Header />
                <main className="flex-1 w-full">{children}</main>
                <Footer />
              </div>
              <Toaster richColors />
            </ThemeProvider>
          </body>
        </html>
      </ClerkProvider>
    )
  }
  ```

2. 实战：更新页面文件:
  - app/[lang]/page.tsx: 让它导入并渲染 <HomePageShell />。
  ```
  // app/[lang]/page.tsx

  import { HomePageShell } from '@/app/ui/home-page-shell'

  // 注意：即使 HomePageShell 是一个服务端组件，
  // 我们的 Page 组件本身也可以是一个简单的同步组件，因为它不直接执行异步操作。
  export default function Home() {
    return <HomePageShell />
  }
  ```

  - 创建并更新 app/[lang]/gallery/page.tsx: 让它导入并渲染 <GalleryPageShell />。
  ```
  // app/[lang]/gallery/page.tsx
  import { GalleryPageShell } from '@/app/ui/gallery-page-shell'

  export default function GalleryPage() {
    // 在第六章，我们会在这里获取真实数据并作为 props 传递下去
    return <GalleryPageShell />
  }
  ```

  - 创建并更新 app/[lang]/log/page.tsx: 让它导入并渲染 <LogPageShell />。
  ```
  // app/[lang]/log/page.tsx
  import { LogPageShell } from '@/app/ui/log-page-shell'

  export default function LogPage() {
    return <LogPageShell />
  }
  ```
  
本章实操验证
现在，重启你的开发服务器，并依次访问 /, /gallery, /log。你应该能看到一个布局完整、结构清晰、且填充了占位符内容的网站框架。
恭喜你！我们已经成功地为“数字花园”搭建了完整的“视觉骨架”。现在，它看起来已经非常像一个真实的网站了！在下一章，我们将为它注入真实的灵魂——数据。