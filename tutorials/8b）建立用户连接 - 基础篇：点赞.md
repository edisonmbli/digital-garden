# 8-b）建立用户连接 - 基础篇：点赞功能完整实现
> 章节目标: 将我们的摄影作品展示网站从单向的"内容广播"平台，升级为支持用户互动的社区平台。本章将实现完整的点赞功能，包括权限控制、数据管理、UI交互和用户体验优化。

## 前言：从静态展示到社交互动的跃迁
还记得我们最初的网站吗？用户只能静静地欣赏照片，就像在博物馆里隔着玻璃看展品。现在，我们要打破这层玻璃，让用户能够表达他们的喜爱——通过点赞功能。
这看似简单的一个❤️，背后却涉及了现代 Web 开发的方方面面：权限控制、数据库设计、状态管理、用户体验...让我们一步步来征服它！

## 8.1 数据基础：为社交互动搭建舞台

### 理解我们的数据架构

在开始之前，让我们先理解一下我们的数据架构。我们有两个数据源：
- Sanity: 存储照片的内容数据（图片、标题、描述等）
- Postgres: 存储用户互动数据（点赞、评论等）

这种"内容与互动分离"的设计，让我们既能享受 Headless CMS 的便利，又能灵活地处理用户数据。

### 确保 Post 记录的存在

上一章准备篇，我们已做好Sanity与Postgres的连接，确保每一张照片在数据库中都有对应的Post记录

### 用户权限：打好Role-Based Access Control (RBAC) 的基础

升级我们的 app/api/webhooks/clerk/route.ts，让它在将用户数据同步到我们自己数据库的同时，通过 Clerk 的后端 API，回调 Clerk，为这个新用户的 publicMetadata 设置上默认的角色‘user’
> 其优势在于:
> - 自动化: 无论用户是通过邮箱注册，还是通过 GitHub/Google 社交登录，只要新用户在 Clerk 中被创建，这个 Webhook 就会被触发，确保每一个新用户都能被自动赋予 'user' 角色。
> - 逻辑内聚: 所有与“新用户创建”相关的业务逻辑（同步到我方数据库、设置默认角色），都被集中在了这一个 Webhook 处理器中，非常清晰和易于维护。

实战：在用户创建环节及时赋予默认user权限
创建types/clerk.d.ts，为 Clerk 定义自定义类型扩充
```
export {}

declare global {
  namespace ClerkTypes {
    interface UserPublicMetadata {
      role?: 'admin' | 'user'
    }
  }
}

打开app/api/webhooks/clerk/route.ts，为clerk/route.ts增加用户创建时的回调：
// app/api/webhooks/clerk/route.ts

import { Webhook } from 'svix'
import { headers } from 'next/headers'
import { WebhookEvent, clerkClient } from '@clerk/nextjs/server' // 1. 导入 clerkClient
import prisma from '@/lib/prisma'
import { NextResponse } from 'next/server'

export async function POST(req: Request) {
  // ... (Webhook 密钥和签名验证逻辑保持不变) ...
  const wh = new Webhook(WEBHOOK_SECRET!);
  let evt: WebhookEvent;
  try {
    evt = wh.verify(...) as WebhookEvent;
  } catch (err) {
    // ...
  }

  const eventType = evt.type;

  if (eventType === 'user.created') {
    const { id, email_addresses, image_url, first_name, last_name } = evt.data;

    // 2. 将用户数据写入到我们自己的数据库
    await prisma.user.create({
      data: {
        id: id,
        email: email_addresses[0].email_address,
        name: `${first_name || ''} ${last_name || ''}`.trim(),
        avatarUrl: image_url,
      },
    });

    // 3. (关键新增) 通过 Clerk 后端 API，为新用户设置默认角色
    const client = await clerkClient()
    await client.users.updateUserMetadata(id, {
      publicMetadata: {
        role: 'user',  // 设置默认角色为 'user'
      },
    })

    return NextResponse.json({ message: 'User created and role assigned' }, { status: 201 });
  }

  // ... (user.updated 和 user.deleted 的逻辑保持不变) ...

  return new Response('', { status: 200 });
}
```


## 8.2 核心功能：实现点赞的"一键切换"

### 智能的 toggleLike 函数

点赞功能的核心是"切换"逻辑：如果用户已经点赞了，就取消点赞；如果没有点赞，就添加点赞。

在 `lib/dal.ts` 中添加：

```typescript
export async function toggleLikePost(postId: string) {
  const { userId } = await auth()
  if (!userId) throw new Error('Unauthorized')

  // 检查用户是否已经点赞过这个帖子
  const existingLike = await prisma.like.findUnique({
    where: {
      postId_userId: {
        postId,
        userId,
      },
    },
  })

  if (existingLike) {
    // 如果已经点赞，则取消点赞（硬删除）
    await prisma.like.delete({
      where: {
        id: existingLike.id,
      },
    })
    return { action: 'unliked' as const, success: true }
  } else {
    // 如果没有点赞，则创建点赞
    await prisma.like.create({
      data: {
        postId,
        userId,
      },
    })
    return { action: 'liked' as const, success: true }
  }
}
```

### Server Action：连接前后端的桥梁

在 `lib/actions.ts` 中创建对应的 Server Action：

```typescript
'use server'

import { revalidateTag } from 'next/cache'
import * as dal from './dal'

export async function toggleLikeAction(postId: string) {
  try {
    const result = await dal.toggleLikePost(postId)
    
    // 重要：让相关缓存失效，确保数据实时更新
    revalidateTag(`post-interactions:${postId}`)
    
    return result
  } catch (error) {
    console.error('Toggle like error:', error)
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    }
  }
}
```

## 8.3 权限控制：优雅的登录引导

### 问题：如何处理未登录用户？

当未登录用户尝试点赞时，我们不能简单地弹出错误。我们需要：
1. 友好地提示用户需要登录
2. 提供便捷的登录入口
3. 登录后能回到原来的页面和照片

### 解决方案：AuthModal + URL 参数

我们创建一个认证模态框组件 `app/ui/auth-modal.tsx`：

```typescript
'use client'

import { SignIn } from '@clerk/nextjs'
import { ResponsiveDialog } from './responsive-dialog'

interface AuthModalProps {
  isOpen: boolean
  onClose: () => void
  redirectUrl?: string
}

export function AuthModal({ isOpen, onClose, redirectUrl }: AuthModalProps) {
  return (
    <ResponsiveDialog open={isOpen} onOpenChange={onClose}>
      <div className="flex flex-col items-center justify-center p-6">
        <h2 className="text-xl font-semibold mb-4">登录以继续</h2>
        <p className="text-muted-foreground mb-6 text-center">
          登录后即可为喜欢的照片点赞
        </p>
        
        <SignIn 
          routing="hash"  // 防止路由冲突
          redirectUrl={redirectUrl}
          appearance={{
            elements: {
              rootBox: "w-full",
              card: "shadow-none border-0"
            }
          }}
        />
      </div>
    </ResponsiveDialog>
  )
}
```

### URL 参数方案：登录后的无缝回归

为了让用户登录后能回到之前查看的照片，我们在 `photo-grid.tsx` 中实现 URL 参数方案：

```typescript
// app/ui/photo-grid.tsx
'use client'

import { useEffect, useState } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'

export function PhotoGrid({ photos = [] }: { photos: EnrichedPhoto[] }) {
  const [selectedPhoto, setSelectedPhoto] = useState<EnrichedPhoto | null>(null)
  const [showAuthModal, setShowAuthModal] = useState(false)
  const [pendingPhoto, setPendingPhoto] = useState<EnrichedPhoto | null>(null)
  
  const router = useRouter()
  const searchParams = useSearchParams()

  // 🔥 关键：检查 URL 参数，自动打开对应照片
  useEffect(() => {
    const photoId = searchParams.get('photo')
    if (photoId && photos.length > 0) {
      const photo = photos.find(p => p._id === photoId)
      if (photo) {
        setSelectedPhoto(photo)
        // 清除 URL 参数，避免重复打开
        const newUrl = new URL(window.location.href)
        newUrl.searchParams.delete('photo')
        router.replace(newUrl.pathname + newUrl.search, { scroll: false })
      }
    }
  }, [photos, searchParams, router])

  const handleAuthRequired = (photo: EnrichedPhoto) => {
    setPendingPhoto(photo)
    setShowAuthModal(true)
  }

  const handleAuthSuccess = () => {
    setShowAuthModal(false)
    if (pendingPhoto) {
      setSelectedPhoto(pendingPhoto)
      setPendingPhoto(null)
    }
  }

  // 构建带照片 ID 的重定向 URL
  const getRedirectUrl = () => {
    const currentUrl = new URL(window.location.href)
    if (pendingPhoto) {
      currentUrl.searchParams.set('photo', pendingPhoto._id)
    }
    return currentUrl.toString()
  }

  return (
    <>
      {/* 照片网格 */}
      {/* ... */}

      {/* 认证模态框 */}
      <AuthModal
        isOpen={showAuthModal}
        onClose={() => setShowAuthModal(false)}
        redirectUrl={getRedirectUrl()}
      />
    </>
  )
}
```

## 8.4 UI 组件：让点赞变得有趣

### 增强版点赞按钮

我们创建一个功能丰富的点赞按钮 `app/ui/enhanced-like-button.tsx`：

```typescript
'use client'

import { useState, useTransition } from 'react'
import { Heart } from 'lucide-react'
import { useUser } from '@clerk/nextjs'
import { Button } from '@/components/ui/button'
import { toggleLikeAction } from '@/lib/actions'

interface EnhancedLikeButtonProps {
  postId: string
  initialLikesCount: number
  initialIsLiked: boolean
  onAuthRequired?: () => void
}

export function EnhancedLikeButton({
  postId,
  initialLikesCount,
  initialIsLiked,
  onAuthRequired
}: EnhancedLikeButtonProps) {
  const { isSignedIn } = useUser()
  const [isPending, startTransition] = useTransition()
  
  // 本地状态管理，提供即时反馈
  const [likesCount, setLikesCount] = useState(initialLikesCount)
  const [isLiked, setIsLiked] = useState(initialIsLiked)

  const handleClick = () => {
    if (!isSignedIn) {
      onAuthRequired?.()
      return
    }

    // 乐观更新：立即更新 UI
    const newIsLiked = !isLiked
    const newCount = newIsLiked ? likesCount + 1 : likesCount - 1
    
    setIsLiked(newIsLiked)
    setLikesCount(newCount)

    // 后台执行实际操作
    startTransition(async () => {
      const result = await toggleLikeAction(postId)
      
      if (!result.success) {
        // 如果失败，回滚 UI 状态
        setIsLiked(!newIsLiked)
        setLikesCount(likesCount)
        console.error('点赞操作失败:', result.error)
      }
    })
  }

  return (
    <Button
      variant="ghost"
      size="sm"
      onClick={handleClick}
      disabled={isPending}
      className={`transition-all duration-200 ${
        isLiked 
          ? 'text-red-500 hover:text-red-600' 
          : 'text-muted-foreground hover:text-red-500'
      }`}
    >
      <Heart 
        className={`mr-2 h-4 w-4 transition-all duration-200 ${
          isLiked ? 'fill-current scale-110' : ''
        }`} 
      />
      <span className="tabular-nums">
        {likesCount} {likesCount === 1 ? 'like' : 'likes'}
      </span>
    </Button>
  )
}
```

### 数据整合：让一切协同工作

最后，我们需要更新 `getGroupAndPhotosBySlug` 函数，确保它返回点赞按钮所需的所有数据：

```typescript
// lib/dal.ts (更新数据查询部分)
const photoesInfoFromDb = await prisma.post.findMany({
  where: {
    sanityDocumentId: { in: photoContentIds },
    contentType: 'photo',
    isDeleted: false,
  },
  select: {
    id: true,
    sanityDocumentId: true,
    likes: userId
      ? {
          where: { userId },
          select: { id: true },
        }
      : false,
    _count: {
      select: {
        likes: true,
        comments: true,
      },
    },
  },
})

// 数据整合
const enrichedPhotos: EnrichedPhoto[] = collectionDataFromSanity.photos.map(
  (photo: Photo) => {
    const photoData = photoesMap.get(photo._id)
    return {
      ...photo,
      post: photoData
        ? {
            id: photoData.id,
            likesCount: photoData._count.likes,
            commentsCount: photoData._count.comments,
            isLikedByUser: userId ? photoData.likes.length > 0 : false,
          }
        : null,
    }
  }
)
```

## 8.5 实战经验：踩过的坑和解决方案

### 坑点 1：Clerk 路由冲突

问题: 在集成 Clerk 的 SignIn 组件时，可能会遇到路由警告：
```
The '/zh/gallery/japan' route is not a catch-all route
```

解决方案: 在 SignIn 组件中添加 `routing="hash"` 配置：
```typescript
<SignIn 
  routing="hash"  // 防止 Clerk 干扰 Next.js 路由
  redirectUrl={redirectUrl}
/>
```

### 坑点 2：缓存更新时机

问题: 点赞后数据不会立即更新。

解决方案: 在 Server Action 中正确使用 `revalidateTag`：
```typescript
export async function toggleLikeAction(postId: string) {
  const result = await dal.toggleLikePost(postId)
  
  // 关键：让相关缓存失效
  revalidateTag(`post-interactions:${postId}`)
  
  return result
}
```

### 坑点 3：乐观更新的回滚

问题: 网络请求失败时，UI 状态与实际状态不一致。

解决方案: 实现乐观更新的回滚机制：
```typescript
const handleClick = () => {
  // 乐观更新
  setIsLiked(newIsLiked)
  setLikesCount(newCount)

  startTransition(async () => {
    const result = await toggleLikeAction(postId)
    
    if (!result.success) {
      // 回滚状态
      setIsLiked(!newIsLiked)
      setLikesCount(likesCount)
    }
  })
}
```

## 8.6 性能优化：让点赞飞起来

### 1. 批量数据获取
使用 `findMany` 而不是多个 `findUnique` 调用：
```typescript
const photoesInfoFromDb = await prisma.post.findMany({
  where: {
    sanityDocumentId: { in: photoContentIds },
  },
  // ...
})
```

### 2. 精确的数据选择
只查询需要的字段：
```typescript
select: {
  id: true,
  sanityDocumentId: true,
  likes: userId ? { where: { userId }, select: { id: true } } : false,
  _count: { select: { likes: true, comments: true } },
},
```

### 3. 智能缓存策略
使用 React.cache 包装数据获取函数：
```typescript
export const getGroupAndPhotosBySlug = cache(
  async (slug: string, lang: Locale, page: number = 1) => {
    // ...
  }
)
```

## 8.7 业界最佳实践：硬删除 vs 软删除

### 为什么选择硬删除？

对于点赞功能，我们选择了硬删除（直接删除数据库记录）而不是软删除（标记为删除）。这是基于以下考虑：

1. 性能优先: 点赞表是高频操作表，保持表的精简对性能至关重要
2. 业务逻辑简单: 点赞/取消点赞是即时性操作，不需要历史记录
3. 存储成本: 避免积累大量"已删除"的点赞记录
4. 业界标准: Instagram、Facebook 等大型社交平台都采用硬删除方案

### 数据完整性保障

虽然使用硬删除，但我们通过以下方式保障数据完整性：
- 使用 Prisma 的 `@@unique([postId, userId])` 约束
- 在 DAL 层进行权限检查
- 使用事务确保操作的原子性

## 8.8 本章验收清单

恭喜！你已经成功实现了一个完整的点赞功能。让我们来验收一下：

### ✅ 核心功能测试
- [ ] 登录用户可以成功点赞照片
- [ ] 点赞后立即看到 UI 更新（乐观更新）
- [ ] 可以取消已点赞的照片
- [ ] 点赞数量正确显示

### ✅ 权限控制测试  
- [ ] 未登录用户点击点赞时显示登录模态框
- [ ] 登录后能回到之前查看的照片
- [ ] URL 参数方案正常工作

### ✅ 用户体验测试
- [ ] 点赞按钮有合适的视觉反馈
- [ ] 加载状态清晰可见
- [ ] 移动端体验良好

### ✅ 性能测试
- [ ] 页面加载速度正常
- [ ] 点赞操作响应迅速
- [ ] 缓存更新及时

### ✅ 错误处理测试
- [ ] 网络错误时有合适的回滚
- [ ] 服务器错误时有友好提示

## 总结：从功能到体验的全面升级

在这一章中，我们不仅实现了点赞功能，更重要的是建立了一套完整的用户互动体系：

1. 数据架构: 建立了 Sanity 内容与 Postgres 互动数据的桥梁
2. 权限体系: 实现了优雅的登录引导和权限控制
3. 用户体验: 通过乐观更新、URL 参数等技术提升了交互体验
4. 性能优化: 采用了批量查询、精确选择等优化策略

这些经验和模式，将为后续的评论功能、用户中心等功能奠定坚实的基础。

下一章，我们将在此基础上实现评论功能，让用户之间的互动更加丰富！