番外篇-2：客户端组件国际化

第六章结束后，网站功能已基本可用，但细心的朋友们可能会注意到，有两个与“国际化”相关的issue隐藏在代码里，分别是：
1）“无限滚动”特性引入了infinite-photo-grid，这是一个client component，其国际化如何实现呢？
2）对collection page进行手工语言切换，直接掉入404

## 1. 客户端组件的国际化
我们之前在服务端，通过 React.cache 和 headers() 解决过 Prop Drilling 的问题。但接下来，当我们需要在客户端组件之间共享状态（比如国际化文本）时，Prop Drilling 的“幽灵”又回来了。

#### 1）方案一：通过 props 传递翻译文本
对于简单的场景，譬如说collection page -> infinite-photo-grid，这个方案足够简单直接，也符合“数据向下流动，组件保持纯净”的React最佳实践
- 实战：
1. 修改字典文件 ，添加相关翻译：
  ```
  //en.json
  {
    // ... existing translations ...
    "gallery": {
      "loading": "Loading...",
      "allPhotosLoaded": "All photos loaded."
    }
  }

  //zh.json
  {
    // ... existing translations ...
    "gallery": {
      "loading": "加载中...",
      "allPhotosLoaded": "所有照片已加载完成。"
    }
  }
  ```

2. 修改 InfinitePhotoGrid 组件 ，接收翻译文本作为 props：
  ```
  // app/ui/infinite-photo-grid.tsx
  'use client'

  import { useState, useEffect } from 'react'
  import { useInView } from 'react-intersection-observer'
  import { PhotoGrid } from './photo-grid'
  import { loadMorePhotosAction } from '@/lib/actions'
  import { type Locale } from '@/i18n-config'

  type Photo = { _id: string; imageUrl: string /* ...其他字段... */ }

  interface InfinitePhotoGridProps {
    initialPhotos: Photo[]
    collectionSlug: string
    lang: Locale
    translations: {
      loading: string
      allPhotosLoaded: string
    }
  }

  export function InfinitePhotoGrid({
    initialPhotos,
    collectionSlug,
    lang,
    translations,
  }: InfinitePhotoGridProps) {
    const [photos, setPhotos] = useState(initialPhotos)
    const [page, setPage] = useState(2)
    const [hasMore, setHasMore] = useState(true)
    const [isLoading, setIsLoading] = useState(false)

    const { ref, inView } = useInView()

    useEffect(() => {
      if (inView && hasMore && !isLoading) {
        setIsLoading(true)
        loadMorePhotosAction(collectionSlug, lang, page).then((res) => {
          if (res.photos.length > 0) {
            setPhotos((prevPhotos) => [...prevPhotos, ...res.photos])
            setPage((prevPage) => prevPage + 1)
          }
          setHasMore(res.hasMore)
          setIsLoading(false)
        })
      }
    }, [inView, hasMore, isLoading, collectionSlug, lang, page])

    return (
      <>
        <PhotoGrid photos={photos} />
        <div ref={ref} className="mt-8 text-center">
          {hasMore ? (isLoading ? translations.loading : '') : translations.allPhotosLoaded}
        </div>
      </>
    )
  }
  ```

3. 修改 collection page ，传递翻译文本:
  ```
  // app/[lang]/gallery/[collection-slug]/page.tsx

  import { type Locale } from '@/i18n-config'
  import { getGroupAndPhotosBySlug } from '@/lib/dal'
  import { notFound } from 'next/navigation'
  import { client as sanityClient } from '@/sanity/client'
  import { groq } from 'next-sanity'
  import { InfinitePhotoGrid } from '@/app/ui/infinite-photo-grid'
  import { getDictionary } from '@/lib/dictionary'

  // ... existing generateStaticParams ...

  export default async function CollectionPage({
    params,
  }: {
    params: Promise<{ 'collection-slug': string; lang: Locale }>
  }) {
    const { 'collection-slug': collectionSlug, lang } = await params

    // 并行获取数据和字典
    const [initialGroupData, dictionary] = await Promise.all([
      getGroupAndPhotosBySlug(collectionSlug, lang, 1),
      getDictionary(lang)
    ])

    if (!initialGroupData) {
      notFound()
    }

    return (
      <div className="w-full py-12">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <header className="text-center mb-12">
            <h1 className="text-4xl font-bold">{initialGroupData.name}</h1>
            <p className="text-muted-foreground mt-4 max-w-2xl mx-auto">
              {initialGroupData.description}
            </p>
          </header>
          <main>
            <InfinitePhotoGrid
              initialPhotos={initialGroupData.photos}
              collectionSlug={collectionSlug}
              lang={lang}
              translations={{
                loading: dictionary.gallery.loading,
                allPhotosLoaded: dictionary.gallery.allPhotosLoaded,
              }}
            />
          </main>
        </div>
      </div>
    )
  }
  ```

#### 2）方案二：创建一个“国际化上下文 (i18n Context)”
虽然对于 page -> infinite-photo-grid 这一层传递，方案一是可接受的。但想象一下，接下来 infinite-photo-grid 内部的 <PhotoCard> 需要文本，<PhotoCard> 内部的 <Dialog> 需要文本，<Dialog> 内部的 <CommentForm> 也需要文本……这种层层传递很快会变成一场噩梦。
社区的最佳实践，正是为了解决客户端的“跨层级状态共享”问题而生的，这个工具就是——React Context。

#### 3）最终方案：创建一个“国际化上下文 (i18n Context)”
到第八章，我们将会增加用户互动的特性，届时将引入更多层次的客户端组件。考虑到代码的长期可维护性，这里我们选择采用方案二：创建一个专门的 i18n Provider，它会在我们应用的顶层“注入”完整的字典内容。然后，任何深层嵌套的客户端组件，都可以随时、独立地“按需取用”这个字典，而无需再通过 props 进行传递。

第一步：创建 I18nProvider 和 useI18n Hook
1. 创建文件: 在 app/ 目录下，创建一个新文件夹 context。在其中，创建一个新文件 i18n-provider.tsx。
2. 写入代码:
  ```
  // app/context/i18n-provider.tsx
  'use client';

  import { createContext, useContext } from 'react';

  // 1. 定义我们字典的类型
  type DictionaryType = Awaited<ReturnType<typeof getDictionary>>

  // 2. 创建一个 Context，并提供一个默认值
  const I18nContext = createContext<DictionaryType | null>(null);

  // 3. 创建我们的 Provider 组件
  // 它接收我们从服务端获取的字典，并通过 Context 提供给所有子组件
  export function I18nProvider({
    dictionary,
    children,
  }: {
    dictionary: DictionaryType;
    children: React.ReactNode;
  }) {
    return (
      <I18nContext.Provider value={dictionary}>
        {children}
      </I18nContext.Provider>
    );
  }

  // 4. 创建一个自定义 Hook，让子组件可以轻松地消费这个 Context
  export function useI18n() {
    const context = useContext(I18nContext);
    if (context === null) {
      throw new Error('useI18n must be used within an I18nProvider');
    }
    return context;
  }
  ```

第二步：在根布局中使用 I18nProvider
现在，我们在 layout.tsx 中，获取一次字典，然后用 I18nProvider 将我们的整个应用包裹起来。
  ```
  // app/[lang]/layout.tsx
  import { I18nProvider } from '@/app/context/i18n-provider'; // 1. 导入 Provider
  // ... 其他 import

  export default async function RootLayout({
    children,
    params: { lang },
  }: { /*...*/ }) {
    const dictionary = await getDictionary(lang);
    // ...

    return (
      <ClerkProvider ...>
        <html lang={lang} suppressHydrationWarning>
          <body>
            <ThemeProvider ...>
              {/* 2. 在这里用 Provider 包裹，并将字典作为 value 注入 */}
              <I18nProvider dictionary={dictionary}>
                <div className="relative flex min-h-screen flex-col">
                  <Header />
                  <main className="flex-1">{children}</main>
                  <Footer />
                </div>
              </I18nProvider>
              <Toaster richColors />
            </ThemeProvider>
          </body>
        </html>
      </ClerkProvider>
    );
  }
  ```

第三步：在客户端组件中消费 Context
现在，我们的 <InfinitePhotoGrid /> 组件不再需要接收 dictionary prop，它可以自己通过 useI18n Hook 来获取。
  ```
  app/ui/infinite-photo-grid.tsx (最终版):
  // app/ui/infinite-photo-grid.tsx
  'use client';

  import { useState, useEffect } from 'react';
  import { useInView } from 'react-intersection-observer';
  import { PhotoGrid } from './photo-grid';
  import { loadMorePhotosAction } from '@/lib/actions';
  import { type Locale } from '@/i18n-config';
  import { useI18n } from '@/app/context/i18n-provider'; // 1. 导入我们的 Hook

  // ... Photo 类型定义 ...

  export function InfinitePhotoGrid({
    initialPhotos,
    collectionSlug,
    lang,
  }: {
    initialPhotos: Photo[];
    collectionSlug: string;
    lang: Locale;
  }) {
    const [photos, setPhotos] = useState(initialPhotos);
    const [page, setPage] = useState(2);
    const [hasMore, setHasMore] = useState(true);
    const [isLoading, setIsLoading] = useState(false);
    
    const dictionary = useI18n(); // 2. 在组件内部，直接获取字典！

    const { ref, inView } = useInView();

    useEffect(() => {
      // ... useEffect 逻辑保持不变 ...
    }, [inView, hasMore, isLoading, collectionSlug, lang, page]);

    return (
      <>
        <PhotoGrid photos={photos} />
        <div ref={ref} className="mt-8 text-center text-muted-foreground">
          {/* 3. 使用从 Context 获取的字典 */}
          {hasMore ? (isLoading ? dictionary.gallery.loading : '') : dictionary.gallery.allPhotosLoaded}
        </div>
      </>
    );
  }
  ```
> 提示: 你需要在你的 .json 词典文件中，增加 gallery.loading 和 gallery.allPhotosLoaded 这两个字段的翻译。


## 2. Collection/Log page 多语言切换bug fix
#### 问题现象
在collection和文章页面，用户从中文页面（如 /zh/gallery/norway）切换到英文时，出现 404 错误。预期应该跳转到 /en/gallery/norway_en，但实际跳转到了 /en/gallery/norway。

#### 根本原因
不同语言版本的内容在 Sanity CMS 中使用不同的 slug：
- 中文版：norway
- 英文版：norway_en
而语言切换器只是简单替换 URL 中的语言代码，没有获取目标语言对应的正确 slug，导致英文环境下找不到 norway 这个 slug 的文档。

#### 解决方案探索历程
方案一：在 Layout 层级提供翻译映射 ❌
思路：将 TranslationProvider 从页面层级提升到 layout 层级，通过中间件传递路径信息。
> 尝试过程：
> - 修改 middleware.ts 添加 x-pathname 请求头
> - 在 layout.tsx 中解析路径并获取翻译数据
> - 将翻译映射传递给 TranslationProvider

> 失败原因：
> - Layout 只渲染一次，用户从 /en/gallery → /en/gallery/norway_en 时不会重新渲染
> - 硬编码路径层级判断（pathSegments.length >= 3）不够灵活
> - 增加了系统复杂度但没有解决核心问题

方案二：添加 API 路由动态获取 ❌
思路：创建 /api/translations 路由，在客户端动态获取翻译映射。
> 放弃原因：
> - 增加了不必要的 API 复杂度
> - 违背了"简洁性优先"的设计原则
> - 为了一个功能引入过多基础设施

方案三：Server Action + 按需获取 ✅
思路：在用户点击语言切换时，通过 Server Action 动态获取翻译映射。

#### 最终解决方案详解
采用"按需获取"策略，当用户点击语言切换按钮时，动态解析当前路径，调用 Server Action 获取翻译映射，然后构建正确的目标路径。

方案亮点
1. 简洁性：移除了复杂的 layout 逻辑和不必要的 Provider
2. 灵活性：不依赖路径层级，可处理任意深度的路径结构
3. 按需加载：只在需要时获取翻译数据，避免不必要的请求
4. 无 API 膨胀：使用 Server Action 而非 API 路由
5. 用户体验：添加加载状态，提供即时反馈
  
核心代码改动
1. 创建 Server Action（lib/actions.ts）
  ```
  // 获取翻译映射的 Server Action
  export async function getTranslationMapAction(
    slug: string,
    lang: Locale,
    type: 'collection' | 'log'
  ): Promise<Record<string, string>> {
    try {
      const translations = await getTranslationsBySlug({ slug, lang, type })
      
      // 将翻译数组转换为映射对象
      return translations.reduce((acc, t) => {
        acc[t.language] = t.slug
        return acc
      }, {} as Record<string, string>)
    } catch (error) {
      console.error('Failed to fetch translation map:', error)
      return {}
    }
  }
  ```

2. 重构 LanguageSwitcher（app/ui/language-switcher.tsx）
  ```
  'use client'

  import { usePathname, useRouter } from 'next/navigation'
  import { type Locale } from '@/i18n-config'
  import { getTranslationMapAction } from '@/lib/actions'
  import { useState } from 'react'

  export function LanguageSwitcher() {
    const pathName = usePathname()
    const router = useRouter()
    const [isLoading, setIsLoading] = useState(false)

    const redirectedPathName = async (locale: Locale) => {
      if (!pathName) return `/${locale}`

      const segments = pathName.split('/')

      // 检测当前页面类型和 slug
      if (segments[2] === 'gallery' && segments[3]) {
        // Collection 页面
        const currentSlug = segments[3]
        const currentLang = segments[1] as Locale
        
        try {
          setIsLoading(true)
          const translationMap = await getTranslationMapAction(currentSlug, currentLang, 'collection')
          
          const targetSlug = translationMap[locale]
          if (targetSlug) {
            return `/${locale}/gallery/${targetSlug}`
          }
        } catch (error) {
          console.error('Failed to get translation map:', error)
        } finally {
          setIsLoading(false)
        }
      }
      // ... 类似处理 log 页面

      // 回退到简单的语言替换
      segments[1] = locale
      return segments.join('/')
    }

    const handleLanguageSwitch = async (locale: Locale) => {
      const targetPath = await redirectedPathName(locale)
      router.push(targetPath)
    }

    return (
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="outline" size="icon" disabled={isLoading}>
            <Languages className="h-[1.2rem] w-[1.2rem]" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem onClick={() => handleLanguageSwitch('en')}>
            English
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => handleLanguageSwitch('zh')}>
            中文
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    )
  }

  3. 简化 Layout（app/[lang]/layout.tsx）
  // 移除复杂的路径解析和 TranslationProvider
  export default async function RootLayout({
    children,
    params,
  }: {
    children: React.ReactNode
    params: Promise<{ lang: Locale }>
  }) {
    const { lang } = await params
    const dictionary = await getDictionary(lang)
    const clerkLocalization = getClerkLocalization(lang)

    return (
      <ClerkProvider localization={{ ...clerkLocalization, ...dictionary.clerk }}>
        <html lang="en" suppressHydrationWarning>
          <body className={`${fontSans.variable} ${fontSerif.variable} font-sans min-h-screen w-full bg-background text-foreground antialiased`}>
            <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
              <I18nProvider dictionary={dictionary}>
                <div className="relative flex flex-col min-h-screen w-full">
                  <Header lang={lang} dictionary={dictionary} />
                  <main className="flex-1 w-full">{children}</main>
                  <Footer dictionary={dictionary} />
                </div>
              </I18nProvider>
              <Toaster richColors />
            </ThemeProvider>
          </body>
        </html>
      </ClerkProvider>
    )
  }
  ```

重点环节说明
1. 路径解析逻辑：通过 pathName.split('/') 动态解析当前页面类型和 slug，避免硬编码
2. 错误处理：包含完整的 try-catch 错误处理和回退机制
3. 加载状态：使用 useState 管理加载状态，禁用按钮防止重复点击
4. 类型安全：严格的 TypeScript 类型定义，确保代码健壮性

这个解决方案的核心思想是"按需获取，简洁优先"。通过将复杂逻辑集中在用户交互点（语言切换按钮），避免了在 layout 层级的过度工程化，同时保持了代码的可读性和可维护性。这种方法特别适合处理多语言内容管理系统中的 slug 映射问题。