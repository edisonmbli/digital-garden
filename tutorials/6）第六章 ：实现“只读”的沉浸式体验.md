6）第六章 ：实现“只读”的沉浸式体验
欢迎来到我们旅程的第六章！
在上一章，我们为“数字花园”搭建了完整的“视觉骨架”。它现在看起来已经很像一个真实的网站了，但它还缺少了最重要的东西——灵魂。在这一章，我们将为它注入灵魂，用真实的后端数据，替换掉所有临时的“占位符”，构建出一个完整的、可深入浏览的、且对搜索引擎友好的沉浸式内容体验。

## 6.1 章节目标与理念
- 核心任务: 我们将正式打通从 Sanity (内容) 和 Prisma (数据) 到前端组件的完整数据链路，让我们的网站“活”起来。
- 核心理念: 我们不仅要展示数据，更要确保这个过程是高性能的（通过静态生成）、对SEO友好的（通过元数据）、且用户体验绝佳的（通过无限滚动和模态框）。

## 6.2 构建数据访问层 (DAL) - 读取操作
在开始渲染页面之前，我们必须先教会我们的应用“如何从后端获取数据”。所有这些逻辑，都将被封装在我们 app/lib/dal.ts 这个“数据访问层”中。
> 教程：id vs. slug 的“内外有别”
> 在编写查询时，你会注意到我们同时用到了 id 和 slug。请记住这个最佳实践：
> - slug (对外): 一个唯一的、人类可读的字符串，专门用于构建面向公众的 URL (e.g., /log/my-first-post)，对 SEO 极其重要。
> - id (对内): 一个唯一的、不可变的标识符，专门用于数据库内部的记录关联（比如，一条评论通过 postId 关联到一篇文章）。

实战：编写数据读取函数
打开 app/lib/dal.ts，我们将在这里编写所有需要的数据读取函数，并用 React.cache 包裹，以实现单次请求内的自动去重，保证性能。
  ```
  // app/lib/dal.ts
  import 'server-only';
  import { cache } from 'react';
  import prisma from './prisma';
  import { client as sanityClient } from '@/sanity/client'; // 假设你已创建 Sanity 客户端
  import { groq } from 'next-sanity';
  import { type Locale } from '@/i18n-config';

  // --- Sanity Queries ---

  export const getFeaturedGroups = cache(async (lang: Locale) => {
    const query = groq`*[_type == "collection" && language == $lang] | order(_createdAt desc) {
      _id,
      name,
      "slug": slug.current,
      "coverImageUrl": coverImage.asset->url
    }`;
    return sanityClient.fetch<any[]>(query, { lang });
  });

  export const getLogPosts = cache(async (lang: Locale) => {
    const query = groq`*[_type == "log" && language == $lang] | order(publishedAt desc) {
      _id,
      title,
      "slug": slug.current,
      publishedAt,
      excerpt
    }`;
    return sanityClient.fetch<any[]>(query, { lang });
  });

  export const getGroupAndPhotosBySlug = cache(async (slug: string, lang: Locale) => {
    // 注意：这个查询会更复杂，需要JOIN和分页，我们先用一个简化版
    const query = groq`*[_type == "collection" && slug.current == $slug && language == $lang][0] {
      name,
      description,
      "photos": *[_type == "photo" && references(^._id)] {
        _id,
        "imageUrl": image.asset->url,
        "metadata": image.asset->metadata.lqip // 获取低质量图片占位符 (LQIP)
      }
    }`;
    return sanityClient.fetch<any>(query, { slug, lang });
  });

  export const getLogPostBySlug = cache(async (slug: string, lang: Locale) => {
    const query = groq`*[_type == "log" && slug.current == $slug && language == $lang][0] {
      title,
      content, // Portable Text
      publishedAt,
      "author": author->{ name, "avatarUrl": image.asset->url }
    }`;
    return sanityClient.fetch<any>(query, { slug, lang });
  });


  // --- Prisma Queries ---

  export const getLikesAndCommentsForPost = cache(async (contentId: string) => {
    // 我们通过 Sanity 的 _id (存在 Post.contentId) 来查找我们自己的 Post
    const post = await prisma.post.findUnique({
      where: { contentId },
      include: {
        likes: {
          select: { userId: true }
        },
        comments: {
          include: {
            user: {
              select: { name: true, avatarUrl: true }
            },
            replies: true // 预加载回复
          },
          where: { parentId: null }, // 只获取顶级评论
          orderBy: { createdAt: 'desc' }
        }
      }
    });
    return post;
  });
  ```

## 6.3 填充核心列表页：让花园“枝繁叶茂”
在前面的步骤中，我们已经建立起了强大的数据访问层 (DAL) 和精准的 SEO 元数据生成机制。现在，是时候让我们的辛勤工作开花结果了。我们将用从 Sanity 和 Prisma 获取的真实数据，来彻底替换掉那些临时的“占位符”，让我们的首页、影像馆和日志页面，真正地“活”起来。

#### 核心实践：重构首页 (/)
首页是我们“数字花园”的门面，它需要第一时间就用最精华的内容抓住访客的眼球。
- 技术要点:
  1. 打开 app/[lang]/page.tsx 文件。
  2. 与之前调用 getDictionary 并行，我们现在新增一个 await 调用，从我们的 DAL 中获取精选的影像组数据：const heroCollections = await getHeroCollections(lang);。
  3. 我们将不再直接使用 HomePageShell，而是将获取到的 dictionary 和 heroCollections 数据，作为 props，传递给一个更具体的、负责渲染的 UI 组件（例如，我们可以将 HomePageShell 重命名并改造为 HomePageClient，因为它内部的 Slider 可能需要客户端交互）。
  4. 在 HomePageClient 组件内部，我们将使用这些真实的 collections 数据，来渲染 Hero 区域的背景轮播或精选卡片。
> 专家提示 (Best Practice): 这种“Page Route 获取数据 -> 传递给 UI 组件渲染”的模式，是 Server Components 最核心、最常见的开发范式。它完美地实现了数据逻辑与视图逻辑的关注点分离。
> 完整代码请参考github仓库

#### 核心实践：重构影像馆列表页 (/gallery)
/gallery 是我们所有“影像组”的陈列馆。
- 技术要点:
  1. 打开 app/[lang]/gallery/page.tsx 文件。
  2. 移除对占位符数据的导入。
  3. 调用我们 DAL 中的 getAllCollections(lang) 函数，来获取所有影像组的数据。
  4. 创建一个新的、可复用的 UI 组件: app/ui/collection-card.tsx。这个组件将负责渲染单个“影像组”卡片的所有视觉细节（封面图、标题等）。
  5. 在 gallery/page.tsx 中，使用 .map() 方法遍历获取到的 collections 数组，为每一项数据，都渲染一个 <CollectionCard /> 组件，并将对应的数据作为 props 传入。
  6. 使用 Tailwind CSS Grid (grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3) 来实现一个响应式的网格布局。
> 完整代码请参考github仓库

#### 核心实践：重构开发者日志列表页 (/log)
/log 是我们与世界分享技术思考的窗口。
- 技术要点:
  1. 打开 app/[lang]/log/page.tsx 文件。
  2. 移除占位符数据，并调用 DAL 中的 getLogPosts(lang) 函数，获取所有日志文章的数据。
  3. 创建一个新的 UI 组件: app/ui/log-post-card.tsx，用于展示单篇文章的预览信息（标题、摘要、发布日期等）。
  4. 在 log/page.tsx 中，同样使用 .map() 方法，将获取到的 posts 数组，渲染为一个 <LogPostCard /> 列表。
  5. 我们将在这里，首次实践我们 PRD 中定义的“内容区 + 侧边栏”的经典博客布局。
> 教程：为何要创建 <CollectionCard /> 和 <LogPostCard />？
> 这是一种被称为“组件化思维”的核心实践。通过将列表中的每一项，都抽象成一个独立的、可复用的组件，我们获得了巨大的好处：
>   - 代码更清晰: page.tsx 只负责获取数据和循环，而卡片的具体样式则被封装在它自己的文件中。
>   - 可维护性更高: 未来如果想修改卡片的样式，你只需要去修改一个文件，所有用到它的地方都会自动更新。
>   - 可复用性: 这个 <LogPostCard /> 组件，未来可能也会被用在首页的“最新文章”模块中。
> 完整代码请参考github仓库

## 6.4 构建动态详情页 (The Drill-Down Experience)
本节目标: 在这一节，我们将构建起用户浏览流程的“最后一公里”——详情页。你将学会如何利用 Next.js App Router 的动态路由段 (Dynamic Segments) 功能，来为成千上万篇独立的内容（文章、影像组），创建高性能的、对 SEO 友好的、且完全静态化的独立页面。

核心要点：动态路由的“静态”魔法
在我们开始编码前，必须理解一个核心概念。像 /log/[slug] 、/gallery/[slug]这样的路径，虽然被称为“动态路由”，但我们的目标，是通过 generateStaticParams 这个函数，让它在构建时 (build time)，就预先为每一个 slug 都生成一个纯粹的静态 HTML 文件。
工作流程如下:
  1. generateStaticParams (提供“待办清单”): 我们告诉 Next.js：“请去获取所有文章的 slug 和 lang，生成一个包含所有可能路径的列表。”
  2. pnpm build (执行清单): Next.js 的构建引擎，会遍历这个清单，并为每一个路径（如 /en/log/post-1, /zh/log/post-1），都完整地运行一次页面组件的渲染流程。
  3. 页面组件 (按清单施工): 页面组件会从 params 中接收到具体的 slug 和 lang，然后调用 DAL 函数，获取只属于这一篇文章的数据，并将其渲染出来。
  4. 最终产出: 构建结束后，你将得到一堆预先生成好的、可以被部署到全球 CDN 的、加载速度极快的静态 HTML 文件。

#### 实战：创建影像组详情页
第一步：创建文件结构
在 app/[lang]/ 目录下，创建一个新的文件夹结构：gallery/[group-slug]。然后，在里面创建一个新文件 page.tsx。

第二步：编写页面代码
将以下内容，完整地复制粘贴到你新建的 app/[lang]/gallery/[group-slug]/page.tsx 文件中。
  ```
  // app/[lang]/gallery/[group-slug]/page.tsx

  import { type Locale } from '@/i18n-config';
  import { getDictionary } from '@/lib/dictionary';
  import { getGroupAndPhotosBySlug } from '@/lib/dal';
  import { notFound } from 'next/navigation';
  import { client as sanityClient } from '@/sanity/client';
  import { groq } from 'next-sanity';

  // --- 静态路径生成 ---
  export async function generateStaticParams() {
    const query = groq`*[_type == "collection" && defined(slug.current) && defined(language)]{ "slug": slug.current, language }`;
    const results = await sanityClient.fetch<{ slug: string, language: Locale }[]>(query);
    
    return results.map(r => ({
      lang: r.language,
      'group-slug': r.slug, // 注意：这里的 key 必须与文件夹名 [group-slug] 完全一致
    }));
  }

  // --- 页面组件 ---
  export default async function GalleryGroupPage({ params }: { params: { 'group-slug': string, lang: Locale } }) {
    const dictionary = await getDictionary(params.lang);
    const group = await getGroupAndPhotosBySlug(params['group-slug'], params.lang);

    if (!group) {
      notFound();
    }

    return (
      <div className="container py-12">
        <header className="text-center mb-12">
          <h1 className="text-4xl font-bold">{group.name}</h1>
          <p className="text-muted-foreground mt-4 max-w-2xl mx-auto">
            {group.description}
          </p>
        </header>
        
        <main>
          {/* 这里就是我们将在第七章，用瀑布流布局和无限滚动，来渲染 group.photos 的地方 */}
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {group.photos.map(photo => (
              <div key={photo._id} className="aspect-square bg-muted rounded-lg">
                {/* 临时占位符，我们会在后面用 <Image /> 替换 */}
              </div>
            ))}
          </div>
        </main>
      </div>
    );
  }
  ```
> 专家提示 (Best Practice): 注意 generateStaticParams 返回的对象中，'group-slug' 这个 key。它必须与你的动态路由文件夹 [group-slug] 的名称，在拼写上完全一致，Next.js 才能正确地将它们匹配起来。

第三步：链接gallery列表页
为gallery页面内每个collection，增加跳转链接；主要修改点：
> 1. 在 gallery/page.tsx 中 ：
>   - 将 lang 参数传递给 GalleryPageShell 组件
>   
> 2. 在 gallery-page-shell.tsx 中 ：   
>   - 导入 Link 组件和 Locale 类型
>   - 更新 GalleryPageShellProps 接口，添加 lang: Locale 属性
>   - 将原来的 div 容器替换为 Link 组件
>   - 使用 href={ /${lang}/gallery/${collection.slug} } 构建正确的路由
>   - 添加 block 类名确保 Link 组件正确显示
这样，当用户点击任何一个 collection 卡片时，就会跳转到对应的 [lang]/gallery/[collection-slug] 页面，路由会根据当前页面的语言和所点击的 collection slug 正确拼接

#### 实战：创建开发者日志详情页
第一步：创建文件结构
在 app/[lang]/ 目录下，创建一个新的文件夹结构：log/[slug]。然后，在里面创建一个新文件 page.tsx。

第二步：编写页面代码
将以下内容，完整地复制粘贴到你新建的 app/[lang]/log/[slug]/page.tsx 文件中。
  ```
  // app/[lang]/log/[slug]/page.tsx

  import { type Locale } from '@/i18n-config';
  import { getDictionary } from '@/lib/dictionary';
  import { getLogPostBySlug, getLikesAndCommentsForPost } from '@/lib/dal';
  import { notFound } from 'next/navigation';
  import { client as sanityClient } from '@/sanity/client'; // 需要 sanity client 来生成 static params
  import { groq } from 'next-sanity';

  // --- 步骤 1: 静态路径生成 (SSG) ---
  // 告诉 Next.js 需要为哪些语言和 slug 的组合，预先生成静态页面
  export async function generateStaticParams() {
    // 获取所有语言的所有日志文章的 slug
    const query = groq`*[_type == "log" && defined(slug.current) && defined(language)]{ "slug": slug.current, language }`;
    const results = await sanityClient.fetch<{ slug: string, language: Locale }[]>(query);
    
    return results.map(r => ({
      lang: r.language,
      slug: r.slug,
    }));
  }

  // --- 步骤 3: 页面组件 ---
  export default async function LogPostPage({ params }: { params: { lang: Locale, slug: string } }) {
    // 1. 并行获取所有需要的数据
    const dictionary = await getDictionary(params.lang);
    const postContent = await getLogPostBySlug(params.slug, params.lang);

    // 如果文章不存在，显示 404 页面
    if (!postContent) {
      notFound();
    }

    // 2. 注意：这里我们通过 postContent._id 来获取关联的互动数据
    const interactions = await getLikesAndCommentsForPost(postContent._id);

    return (
      <article className="container py-12 max-w-3xl mx-auto">
        <header className="mb-8 text-center">
          <h1 className="text-4xl font-bold tracking-tighter leading-tight">
            {postContent.title}
          </h1>
          <p className="text-muted-foreground mt-2">
            {new Date(postContent.publishedAt).toLocaleDateString(params.lang, {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
            })} by {postContent.author.name}
          </p>
        </header>
        
        <div className="prose dark:prose-invert max-w-none">
          {/* 在这里，我们将需要一个组件来渲染 Portable Text (postContent.content) */}
          {/* 我们将在第七章，深入交互时，再来创建这个 <PortableTextRenderer /> 组件 */}
        </div>

        <section className="mt-12">
          <h2 className="text-2xl font-bold mb-4">Interactions</h2>
          {/* 在这里，我们将需要组件来渲染点赞按钮和评论区 */}
          {/* 这同样将在第七章实现 */}
          <p>{interactions?.likes.length || 0} Likes</p>
        </section>
      </article>
    );
  }
  ```

第三步：链接log列表页
为log页面内每个文章入口，增加跳转链接；主要修改点：
> 1. 在 log/page.tsx 中 ：
>   - 将 lang 参数传递给 LogPageShell 组件
>     
> 2. 在 log-page-shell.tsx 中 ：
>   - 导入 Locale 类型
>   - 更新 LogPageShellProps 接口，添加 lang: Locale 属性
>   - 将链接路径从 /log/${post.slug} 修改为 /${lang}/log/${post.slug}
这样，当用户点击任何一个 log post 卡片时，就会跳转到对应的 [lang]/log/[slug] 页面，路由会根据当前页面的语言和所点击的 post slug 正确拼接

## 6.5 锦上添花：用“模态框”升级图片浏览体验
现在，是时候让我们的Collection详情页(/gallery/[collection-slug])，展示出它应有的、丰富多彩的真实面貌了。

#### 实战：渲染真实的瀑布流相册
1. “召唤”我们需要的 shadcn/ui 组件: 我们需要一个 Dialog (对话框) 来作为模态框的基础。
`pnpm dlx shadcn@latest add dialog`

2. 创建照片网格客户端组件 (photo-grid.tsx):
  - 教程：为何需要新组件？ 因为打开/关闭模态框、记录当前选中的是哪张照片，这些都需要用到 useState，所以这部分逻辑必须被封装在一个客户端组件 ('use client') 中。这就是 App Router “服务端页面 + 客户端交互岛屿”的最佳实践。
  - 创建文件: app/ui/photo-grid.tsx
  - 写入代码:
  ```
  // app/ui/photo-grid.tsx
  'use client';

  import { useState } from 'react';
  import Image from 'next/image';
  import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";

  // 我们需要一个类型来描述单张照片的数据结构
  type Photo = {
    _id: string;
    imageUrl: string;
    title?: string;
    description?: string;
    metadata?: {
      lqip: string; // 低质量图片占位符
    };
  };

  export function PhotoGrid({ photos }: { photos: Photo[] }) {
    const [selectedPhoto, setSelectedPhoto] = useState<Photo | null>(null);

    return (
      <>
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {photos.map((photo) => (
            <div 
              key={photo._id} 
              className="aspect-square rounded-lg overflow-hidden cursor-pointer"
              onClick={() => setSelectedPhoto(photo)}
            >
              <Image
                src={photo.imageUrl}
                alt={photo.title || 'A photo from the collection'}
                width={400}
                height={400}
                className="w-full h-full object-cover transition-transform duration-300 hover:scale-110"
                placeholder="blur"
                blurDataURL={photo.metadata?.lqip}
              />
            </div>
          ))}
        </div>

        {/* 照片详情模态框 */}
        <Dialog open={!!selectedPhoto} onOpenChange={() => setSelectedPhoto(null)}>
          <DialogContent className="max-w-4xl">
            {selectedPhoto && (
              <>
                <DialogHeader>
                  <DialogTitle>{selectedPhoto.title}</DialogTitle>
                </DialogHeader>
                <div className="relative aspect-video">
                  <Image
                    src={selectedPhoto.imageUrl}
                    alt={selectedPhoto.title || 'A photo from the collection'}
                    fill
                    className="object-contain"
                  />
                </div>
                {/* 在这里可以添加照片描述、点赞评论区等 */}
              </>
            )}
          </DialogContent>
        </Dialog>
      </>
    );
  }
  ```

3. 更新主页面 (gallery/[collection-slug]/page.tsx): 
现在，让我们的页面来获取真实数据，并使用刚刚创建的 <PhotoGrid /> 组件。
  ```
  // app/[lang]/gallery/[collection-slug]/page.tsx
  import { type Locale, generateStaticParams } from '@/i18n-config';
  import { getDictionary } from '@/lib/dictionary';
  import { getGroupAndPhotosBySlug } from '@/lib/dal';
  import { notFound } from 'next/navigation';
  import { PhotoGrid } from '@/app/ui/photo-grid'; // 导入我们新的客户端组件

  // ... generateStaticParams 和 generateMetadata 函数保持不变 ...

  export default async function CollectionPage({ params }: { params: { 'collection-slug': string, lang: Locale } }) {
    const { lang } = params;
    const group = await getGroupAndPhotosBySlug(params['collection-slug'], lang);

    if (!group) {
      notFound();
    }

    return (
      <div className="container py-12">
        <header className="text-center mb-12">
          <h1 className="text-4xl font-bold">{group.name}</h1>
          <p className="text-muted-foreground mt-4 max-w-2xl mx-auto">
            {group.description}
          </p>
        </header>

        <main>
          {/* 使用 PhotoGrid 来渲染照片，并传入真实数据 */}
          <PhotoGrid photos={group.photos} />
        </main>
      </div>
    );
  }
  ```
> 教程：关于“数据预取”与即时模态框
> 你可能会想：“为什么我们不在用户点击照片时，才去向服务器请求这张照片的详细数据呢？”
> 这是一个很好的问题，答案在于用户体验。在我们的架构中，我们在加载列表页时，就已经把模态框所需的所有元数据（高清图URL、标题等）都预先获取了回来。
> 这样做的好处是，当用户点击一张照片时，模态框可以瞬间打开，内容立刻呈现，没有任何网络延迟和加载等待。这种“即时”的反馈，对于创造沉浸式的浏览体验至关重要。

- 实操验证
现在，重启你的开发服务器，并完成以下验收：
1. 进入 /gallery 列表页，你应该能看到来自 Sanity 的、真实的“影像组”卡片。
2. 点击任意一个影像组，你应该能进入它的详情页 .../gallery/[collection-slug]。
3. 在这个详情页，你应该能看到一个由真实照片组成的网格布局。
4. 点击任意一张照片，一个模态框会优雅地弹出，展示这张照片的高清大图和标题。
5. 关闭模态框，一切恢复正常。